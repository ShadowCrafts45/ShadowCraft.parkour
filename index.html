<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Shadow-craft — Parkour Edition</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <style>
    html,body { margin:0; height:100%; background:#111; overflow:hidden; font-family:sans-serif; }
    canvas { display:block; }

    #hud {
      position:fixed; left:12px; top:12px; z-index:60;
      background:rgba(0,0,0,0.45); color:#fff;
      padding:10px 12px; border-radius:8px;
      font-family: monospace; font-size:13px;
    }

    #start-screen {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(-45deg, #0f0f0f, #1a1a1a, #222, #0f0f0f);
      background-size: 400% 400%;
      animation: gradientShift 12s ease infinite;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      z-index: 100; color: #fff;
      font-family: 'Segoe UI', sans-serif; text-align: center;
    }

    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    #game-title {
      font-size: 48px; color: #ffd36b;
      text-shadow: 0 0 12px rgba(255,211,107,0.4);
      animation: floatTitle 4s ease-in-out infinite;
    }

    @keyframes floatTitle {
      0% { transform: translateY(0); }
      50% { transform: translateY(-6px); }
      100% { transform: translateY(0); }
    }

    #load-world-button {
      padding: 10px 18px; font-size: 16px;
      background: #ffd36b; color: #000;
      border: none; border-radius: 10px;
      box-shadow: 0 0 12px rgba(255,211,107,0.4);
      cursor: pointer; font-weight: bold;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    #load-world-button:hover {
      transform: scale(1.08);
      box-shadow: 0 0 20px rgba(255,211,107,0.6);
    }

    #controls-ui {
      position:fixed; left:0; right:0; bottom:0;
      display:none; justify-content:space-between;
      padding:12px; z-index:45;
    }

    #joy-left {
      width:140px; height:140px; margin-left:12px;
      position:relative;
    }

    .joy-bg {
      width:100%; height:100%;
      background:rgba(255,255,255,0.04);
      border-radius:50%; border:1px solid rgba(255,255,255,0.08);
      display:flex; align-items:center; justify-content:center;
    }

    .joy-knob {
      width:48px; height:48px;
      background:rgba(255,255,255,0.14);
      border-radius:50%;
      transform:translate(-50%,-50%);
      position:absolute; left:50%; top:50%;
      display:flex; align-items:center; justify-content:center;
      color:#fff; font-size:14px;
    }

    #right-controls {
      margin-right:12px; display:flex;
      flex-direction:column; gap:10px;
      align-items:flex-end;
    }

    .btn {
      width:56px; height:56px;
      background:rgba(255,255,255,0.06);
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.12);
      color:#fff; font-size:20px;
      display:flex; align-items:center; justify-content:center;
      user-select:none;
    }
  </style>
</head>
<body>
  <div id="start-screen">
    <h1 id="game-title">Shadow-craft: Parkour Edition</h1>
    <button id="load-world-button">▶️ Start Parkour</button>
  </div>
  <div id="hud">Loading...</div>

<div id="controls-ui">
  <div id="joy-left">
    <div class="joy-bg"></div>
    <div class="joy-knob" id="joy-knob">•</div>
  </div>
  <div id="right-controls">
    <div id="look-area" style="width: 50vw; height: 100vh;"></div>
    <div id="button-stack">
      <div class="btn" id="btn-jump">⏫</div>
    </div>
  </div>
</div>
  
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js';
const inputState = { jump: false, moveX: 0, moveZ: 0 };
const joystick = { active: false, id: null, startX: 0, startY: 0, dx: 0, dy: 0 };
  
const isMobile = /Mobi|Android|iPhone|iPad|iPod|Tablet/i.test(navigator.userAgent);
const loadBtn = document.getElementById('load-world-button');
const hud = document.getElementById('hud');
const jumpBtn = document.getElementById('btn-jump');
const controlsUI = document.getElementById('controls-ui');
if (isMobile) controlsUI.style.display = 'flex';

let startTime = null;
let lastCheckpoint = null;
jumpBtn.addEventListener('touchstart', () => inputState.jump = true);

const WORLD_W = 100, WORLD_H = 36, WORLD_D = 100;
const BLOCK_AIR = 0;
const BLOCKS = {
  2: { name: 'Stone', color: 0x6e6e6e },
  3: { name: 'Grass', color: 0x2e8b57 },
  4: { name: 'Wood', color: 0x7b4a2b },
  5: { name: 'Leaves', color: 0x3e803e },
  6: { name: 'Sand', color: 0xd2b48c },
  9: { name: 'Gold', color: 0xffc300 }
};

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function idx(x,y,z){ return x + WORLD_W*(z + WORLD_D*y); }

class VoxelWorld {
  constructor(w,h,d,scene){
    this.w=w; this.h=h; this.d=d;
    this.blocks = new Uint8Array(w*h*d);
    this.group = new THREE.Group();
    scene.add(this.group);
    this.generateTerrain();
    this.updateMeshes();
  }
  inBounds(x,y,z){ return x>=0 && y>=0 && z>=0 && x<this.w && y<this.h && z<this.d; }
  get(x,y,z){ if(!this.inBounds(x,y,z)) return BLOCK_AIR; return this.blocks[idx(x,y,z)]; }
  set(x,y,z,v){ if(!this.inBounds(x,y,z)) return; this.blocks[idx(x,y,z)] = v; }
const joy = document.getElementById('joy-left');
const knob = document.getElementById('joy-knob');

joy.addEventListener('touchstart', e => {
  const t = e.changedTouches[0];
  joystick.active = true;
  joystick.id = t.identifier;
  joystick.startX = t.clientX;
  joystick.startY = t.clientY;
}, { passive: false });

joy.addEventListener('touchmove', e => {
  for (const t of e.changedTouches) {
    if (t.identifier === joystick.id) {
      joystick.dx = t.clientX - joystick.startX;
      joystick.dy = t.clientY - joystick.startY;
      const max = 40;
      const dx = Math.max(-max, Math.min(max, joystick.dx));
      const dy = Math.max(-max, Math.min(max, joystick.dy));
      knob.style.transform = `translate(${dx}px, ${dy}px)`;
      inputState.moveX = dx / max;
      inputState.moveZ = dy / max;
    }
  }
}, { passive: false });

joy.addEventListener('touchend', e => {
  for (const t of e.changedTouches) {
    if (t.identifier === joystick.id) {
      joystick.active = false;
      joystick.dx = joystick.dy = 0;
      inputState.moveX = inputState.moveZ = 0;
      knob.style.transform = 'translate(-50%, -50%)';
    }
  }
}, { passive: false });
  const lookArea = document.getElementById('look-area');
let lastTouch = null;

lookArea.addEventListener('touchstart', e => {
  lastTouch = e.touches[0];
}, { passive: false });

lookArea.addEventListener('touchmove', e => {
  const t = e.touches[0];
  const dx = t.clientX - lastTouch.clientX;
  const dy = t.clientY - lastTouch.clientY;
  player.yaw -= dx * 0.005;
  player.pitch -= dy * 0.005;
  player.pitch = clamp(player.pitch, -Math.PI/2 + 0.01, Math.PI/2 - 0.01);
  lastTouch = t;
}, { passive: false });
  
  generateTerrain(){
    for(let x=0;x<this.w;x++){
      for(let z=0;z<this.d;z++){
        const ridge = Math.sin(x*0.08) * Math.cos(z*0.06);
        let h = Math.floor(1 + 3*(0.5 + 0.5*ridge) + Math.floor(Math.random()*1));
        const distEdge = Math.min(x,z,this.w-1-x,this.d-1-z);
        if(distEdge < 3) h = Math.max(1, 1 + Math.floor(Math.random()*1.2));
        for(let y=0;y<h;y++){
          if(distEdge < 3) this.set(x,y,z,6);
          else if(y < h-1) this.set(x,y,z,2);
          else this.set(x,y,z,3);
        }
        if(h>2 && Math.random() < 0.15 && distEdge >= 5){
          const trunk = 2 + Math.floor(Math.random()*2);
          for(let ty=h; ty<h+trunk && ty<this.h-1; ty++) this.set(x,ty,z,4);
          const ly = Math.min(h+trunk, this.h-2);
          for(let ix=-1; ix<=1; ix++) for(let iz=-1; iz<=1; iz++) for(let iy=0; iy<=1; iy++){
            const lx=x+ix, lz=z+iz, lypos=ly+iy;
            if(this.inBounds(lx,lypos,lz) && this.get(lx,lypos,lz)===BLOCK_AIR) this.set(lx,lypos,lz,5);
          }
        }
      }
    }
      // Spawn platform
    for (let x = 48; x <= 52; x++) {
      for (let z = 48; z <= 52; z++) {
        this.set(x, 10, z, 2); // stone
      }
    }

    // Checkpoints
    for(let i=0;i<5;i++){
      const x = Math.floor(Math.random()*this.w);
      const z = Math.floor(Math.random()*this.d);
      const y = Math.floor(12 + Math.random()*20);
      this.set(x,y,z,9); // gold
    }
  }

  updateMeshes(){
    while(this.group.children.length){
      const c = this.group.children.pop();
      c.geometry?.dispose?.(); c.material?.dispose?.();
    }
    const cubeGeom = new THREE.BoxGeometry(1,1,1);
    const tmp = new THREE.Matrix4();
    const lists = {};
    for(let x=0;x<this.w;x++) for(let y=0;y<this.h;y++) for(let z=0;z<this.d;z++){
      const bid = this.get(x,y,z);
      if(bid && bid!==BLOCK_AIR) (lists[bid]=lists[bid]||[]).push({x,y,z});
    }
    Object.keys(lists).forEach(k=>{
      const id = parseInt(k);
      const arr = lists[k];
      const mat = new THREE.MeshLambertMaterial({ color: BLOCKS[id].color });
      const inst = new THREE.InstancedMesh(cubeGeom, mat, arr.length);
      for(let i=0;i<arr.length;i++){
        tmp.makeTranslation(arr[i].x+0.5, arr[i].y+0.5, arr[i].z+0.5);
        inst.setMatrixAt(i,tmp);
      }
      this.group.add(inst);
    });
  }
}

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(1,2,3);
scene.add(light);

const world = new VoxelWorld(WORLD_W, WORLD_H, WORLD_D, scene);
const player = {
  pos: new THREE.Vector3(50, 12, 50),
  vel: new THREE.Vector3(),
  yaw: 0,
  pitch: 0
};
  document.addEventListener('click', () => {
  if (!isMobile) document.body.requestPointerLock?.();
});

function onMouseMove(e) {
  player.yaw -= e.movementX * 0.0025;
  player.pitch -= e.movementY * 0.0025;
  player.pitch = clamp(player.pitch, -Math.PI/2 + 0.01, Math.PI/2 - 0.01);
}

document.addEventListener('pointerlockchange', () => {
  if (document.pointerLockElement === document.body) {
    window.addEventListener('mousemove', onMouseMove);
  } else {
    window.removeEventListener('mousemove', onMouseMove);
  }
});
                               
function tick(){
  
  requestAnimationFrame(tick);

  if (!startTime) startTime = performance.now();
  const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
  hud.innerText = `Parkour Mode\nTime: ${elapsed}s`;

  if (player.pos.y < -10) {
    player.pos.set(50, 12, 50); // respawn
    player.vel.set(0, 0, 0);
  }

  if (inputState.jump && player.pos.y <= 12.01) {
    player.vel.y = 0.25;
    inputState.jump = false;
  }

  player.vel.y -= 0.01; // gravity
  const speed = 0.1;
const forward = new THREE.Vector3(Math.sin(player.yaw), 0, Math.cos(player.yaw));
const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0));
const move = new THREE.Vector3();

move.addScaledVector(forward, -inputState.moveZ * speed);
move.addScaledVector(right, inputState.moveX * speed);
player.pos.add(move);
  
  player.pos.add(player.vel);
const nextPos = player.pos.clone().add(player.vel);
const bx = Math.floor(nextPos.x);
const by = Math.floor(nextPos.y);
const bz = Math.floor(nextPos.z);
if (world.get(bx, by, bz) === BLOCK_AIR) {
  player.pos.copy(nextPos);
} else {
  player.vel.set(0, 0, 0); // stop movement if blocked
  }
  
  const cx = Math.floor(player.pos.x);
  const cy = Math.floor(player.pos.y - 1);
  const cz = Math.floor(player.pos.z);
  if (world.get(cx, cy, cz) === 9 && lastCheckpoint !== `${cx},${cy},${cz}`) {
    lastCheckpoint = `${cx},${cy},${cz}`;
    hud.innerText += `\n✅ Checkpoint reached!`;
  }
const dir = new THREE.Vector3(
  Math.sin(player.yaw),
  Math.sin(player.pitch),
  Math.cos(player.yaw)
);
camera.position.copy(player.pos).add(new THREE.Vector3(0, 1.6, 0));
camera.lookAt(player.pos.clone().add(dir));
  
  camera.lookAt(player.pos.x, player.pos.y + 1.6, player.pos.z + 1);
  renderer.render(scene, camera);
}
loadBtn.addEventListener('click', () => {
  document.getElementById('start-screen').style.display = 'none';

  // ✅ Initialize player and camera here
  player.pos.set(50, 12, 50);
  player.vel.set(0, 0, 0);
  player.yaw = 0;
  player.pitch = 0;

  camera.position.set(50, 13.6, 50);
  camera.lookAt(50, 13.6, 51);

  tick(); // ✅ Start game loop
});
  

</script>
</body>
</html>
